import ioimport copyimport timmfrom torch import optimfrom timm import create_modelfrom torchvision import transformsfrom PIL import Imagefrom collections import OrderedDictfrom timm.models.layers.activations import *device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")def get_tensor(image_bytes):	my_transforms = transforms.Compose([transforms.Resize(256),	                                    transforms.CenterCrop(224),	                                    transforms.ToTensor(),	                                    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])		image = Image.open(io.BytesIO(image_bytes))	return my_transforms(image).unsqueeze(0)cat_to_name = {"0": "Covid-19", "1": "Normal", "2": "Pneumonia"}class_to_idx = {"0": 0, "1": 1, "2": 2, "3": 3}def get_Covid_19_Eff_B0():	model = timm.create_model('efficientnet_b0', pretrained=True)	for param in model.parameters():		param.requires_grad = True	fc = nn.Sequential(OrderedDict([('fc1', nn.Linear(2048, 1000, bias=True)),							     ('BN1', nn.BatchNorm2d(1000, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)),								 ('dropout1', nn.Dropout(0.7)),                                 ('fc2', nn.Linear(1000, 512)),								 ('BN2', nn.BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)),								 ('swish1', Swish()),								 ('dropout2', nn.Dropout(0.5)),								 ('fc3', nn.Linear(512, 128)),								 ('BN3', nn.BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)),							     ('swish2', Swish()),								 ('fc4', nn.Linear(128, 3)),								 ('output', nn.Softmax(dim=1))							 ]))	model.fc = fc	criterion = nn.CrossEntropyLoss()	optimizer = optim.SGD(model.parameters(), lr=0.01,momentum=0.9, nesterov=True, weight_decay=0.0001)	scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=30, gamma=0.1)		CHECK_POINT_PATH = '/Users/mac/PycharmProjects/Covid-19_Chest_Xray/weights/EfficientNet_B0_Covid-19.pth'	checkpoint = torch.load(CHECK_POINT_PATH, map_location='cpu')	model.load_state_dict(checkpoint['model_state_dict'])	best_model_wts = copy.deepcopy(model.state_dict())	optimizer.load_state_dict(checkpoint['optimizer_state_dict'])	scheduler.load_state_dict(checkpoint['scheduler_state_dict'])	best_loss = checkpoint['best_val_loss']	best_acc = checkpoint['best_val_accuracy']	model.eval()	return modeldef get_model_B0():	checkpoint_path = 'weights/EfficientNet_B0.pth'	model = create_model('efficientnet_b0', num_classes=4, checkpoint_path=checkpoint_path)	model.to(device)	model.eval()	return model#def get_model_TResNet_XL():#	checkpoint_path = 'weights/TResNet_XL.pth'#	model = create_model('tresnet_xl', num_classes=4, checkpoint_path=checkpoint_path)#	model.to(device)#	model.eval()#	return modelclass MyFinalEnsemble_cpu(nn.Module):	def __init__(self):		super(MyFinalEnsemble_cpu, self).__init__()		self.Covid = get_Covid_19_Eff_B0()		self.EfficientNet = get_model_B0()		#self.TResNet_XL = get_model_TResNet_XL()	def forward(self, x):		x1 = self.Covid(x)		x2 = self.EfficientNet(x)		#x3 = self.TResNet_XL(x)		#x = sum([x1, x2, x3]) / 3		x = sum([x1, x2]) /2		return x#model = MyFinalEnsemble_cpu()model = get_Covid_19_Eff_B0()model.eval()def prediction(image_bytes):	tensor = get_tensor(image_bytes)	outputs = model.forward(tensor)	# Probs	probs = F.softmax(outputs, dim=1)	# Top probs	top_probs, top_labs = probs.topk(k=3)	top_probs = top_probs.detach().numpy().tolist()[0]	top_labs = top_labs.detach().numpy().tolist()[0]	top_probs = top_probs	# Convert indices to classes	idx_to_class = {val: key for key, val in class_to_idx.items()}	top_names = [cat_to_name[idx_to_class[lab]] for lab in top_labs]	return top_probs, top_names